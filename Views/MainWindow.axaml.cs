using Avalonia;
using Avalonia.Controls;
using Avalonia.Input;
using Avalonia.Interactivity;
using Avalonia.Media;
using Avalonia.Threading;
using Avalonia.VisualTree;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using ZScape.Controls;
using ZScape.Models;
using ZScape.Services;
using ZScape.Utilities;

namespace ZScape.Views;

/// <summary>
/// Main application window for ZScape - Zandronum Server Browser.
/// </summary>
public partial class MainWindow : Window
{
    private readonly ServerBrowserService _browserService = new();
    private readonly LoggingService _logger = LoggingService.Instance;
    private readonly SettingsService _settings = SettingsService.Instance;
    private readonly WadManager _wadManager = WadManager.Instance;
    private readonly NotificationService _notificationService = NotificationService.Instance;
    private readonly ScreenshotMonitorService _screenshotMonitor = ScreenshotMonitorService.Instance;
    private readonly DispatcherTimer _autoRefreshTimer = new();
    private readonly DispatcherTimer _alertTimer = new();
    private readonly DispatcherTimer _logFlushTimer = new();
    private readonly DispatcherTimer _serverListUpdateTimer = new();
    
    private ServerInfo? _selectedServer;
    private string? _selectedServerAddress; // For selection preservation
    private bool _suppressSelectionEvents; // Prevent selection flicker during updates
    private int _sortColumnIndex = 3; // Default to Players column
    private bool _sortAscending = false;
    private bool _isInitializing = true;
    
    // Server alert state tracking
    private readonly Dictionary<string, ServerAlertState> _serverAlertStates = new();
    
    // Update notification panel
    private Border? _updateNotificationPanel;
    
    // Throttle for server updates
    private bool _serverListNeedsUpdate = false;
    
    // Throttle for log updates
    private readonly List<LogEntry> _pendingLogEntries = [];
    private readonly object _logLock = new();
    
    // Custom control references (initialized after InitializeComponent)
    private ScrollViewer? _serverScrollViewer;
    private ItemsControl? _serverItemsControl;
    private LogPanelControl? _logControl;
    
    // Selection background converter for custom server list
    public static readonly SelectionBackgroundMultiConverter SelectionBackgroundConverter = new();
    
    // Observable collections for data binding
    public ObservableCollection<ServerViewModel> Servers { get; private set; } = [];
    public ObservableCollection<PlayerViewModel> Players { get; } = [];
    public ObservableCollection<WadViewModel> Wads { get; } = [];
    public ObservableCollection<string> GameModes { get; } = [];
    public ObservableCollection<LogEntryViewModel> LogEntries { get; } = [];

    public MainWindow()
    {
        // Start with a fresh log on each launch
        var debugPath = Path.Combine(AppContext.BaseDirectory, "debug.log");
        if (File.Exists(debugPath))
        {
            File.Delete(debugPath);
        }

        // Set DataContext BEFORE InitializeComponent so bindings work
        DataContext = this;
        
        InitializeComponent();
        
        // Set ItemsSource for controls (backup in case XAML binding didn't work)
        SetupItemsSources();
        
        // Initialize game mode filter
        GameModes.Add("All Modes");
        foreach (GameModeType mode in Enum.GetValues<GameModeType>())
        {
            if (mode != GameModeType.Unknown)
            {
                var gm = GameMode.FromType(mode);
                GameModes.Add(gm.Name);
            }
        }
        
        SubscribeToEvents();
        
        // Load settings after UI is ready
        Dispatcher.UIThread.Post(async () => 
        {
            // Check for first-time setup
            if (!_settings.SettingsFileExists)
            {
                await ShowFirstTimeSetupAsync();
            }
            
            // Auto-detect paths if not configured
            AutoDetectPaths();
            
            LoadSettings();
            _isInitializing = false;
            
            // Start screenshot monitoring
            _screenshotMonitor.StartMonitoring();
            
            if (_settings.Settings.RefreshOnLaunch)
            {
                _ = RefreshServersAsync();
            }
            
            // Check for updates in the background
            _ = CheckForUpdatesAsync();
        }, DispatcherPriority.Background);
    }

    // NOTE: InitializeComponent is auto-generated by Avalonia source generator
    // Do not define a custom one - it will conflict with the generated code
    
    private void SetupItemsSources()
    {
        // Write debug to file 
        var debugPath = Path.Combine(AppContext.BaseDirectory, "debug.log");
        
        // Find and store references to controls
        _serverScrollViewer = this.FindControl<ScrollViewer>("ServerScrollViewer");
        _serverItemsControl = this.FindControl<ItemsControl>("ServerItemsControl");
        _logControl = this.FindControl<LogPanelControl>("LogControl");
        var playersGrid = this.FindControl<ItemsControl>("PlayersGrid");
        var wadsList = this.FindControl<ItemsControl>("WadsList");
        var gameModeCombo = this.FindControl<PersistentComboBox>("GameModeComboBox");
        
        File.AppendAllText(debugPath, $"[{DateTime.Now:HH:mm:ss}] ServerItemsControl={_serverItemsControl != null}, LogControl={_logControl != null}\n");
        
        if (_serverItemsControl != null) 
        {
            _serverItemsControl.ItemsSource = Servers;
            
            // Wire up middle-click on scroll viewer and scroll handler to clear hover states
            if (_serverScrollViewer != null)
            {
                _serverScrollViewer.PointerPressed += ServerScrollViewer_PointerPressed;
                _serverScrollViewer.ScrollChanged += ServerScrollViewer_ScrollChanged;
            }
            
            File.AppendAllText(debugPath, $"[{DateTime.Now:HH:mm:ss}] ServerItemsControl initialized\n");
        }
        else
        {
            File.AppendAllText(debugPath, $"[{DateTime.Now:HH:mm:ss}] ERROR: ServerItemsControl NOT FOUND\n");
        }
        
        if (playersGrid != null) playersGrid.ItemsSource = Players;
        if (wadsList != null) wadsList.ItemsSource = Wads;
        
        if (_logControl != null) 
        {
            _logControl.ItemsSource = LogEntries;
            File.AppendAllText(debugPath, $"[{DateTime.Now:HH:mm:ss}] LogControl initialized\n");
        }
        else
        {
            File.AppendAllText(debugPath, $"[{DateTime.Now:HH:mm:ss}] ERROR: LogControl NOT FOUND\n");
        }
        
        if (gameModeCombo != null)
        {
            gameModeCombo.ItemsSource = GameModes;
            gameModeCombo.SelectedIndex = 0;
        }
    }

    #region Event Subscriptions

    private void SubscribeToEvents()
    {
        _browserService.RefreshStarted += BrowserService_RefreshStarted;
        _browserService.RefreshProgress += BrowserService_RefreshProgress;
        _browserService.RefreshCompleted += BrowserService_RefreshCompleted;
        _browserService.ServerUpdated += BrowserService_ServerUpdated;
        _logger.LogAdded += Logger_LogAdded;
        
        // Log flush timer - uses DispatcherTimer to integrate with UI event loop
        _logFlushTimer.Interval = TimeSpan.FromMilliseconds(150);
        _logFlushTimer.Tick += (_, _) => ProcessPendingLogEntries();
        _logFlushTimer.Start();
        
        // Server list update timer - batches updates to avoid blocking UI
        _serverListUpdateTimer.Interval = TimeSpan.FromMilliseconds(300);
        _serverListUpdateTimer.Tick += ServerListUpdateTimer_Tick;
        _serverListUpdateTimer.Start();
        
        // Auto-refresh timer
        _autoRefreshTimer.Tick += AutoRefreshTimer_Tick;
        
        // Alert timer for background server monitoring
        _alertTimer.Interval = TimeSpan.FromSeconds(_settings.Settings.AlertCheckIntervalSeconds > 0 
            ? _settings.Settings.AlertCheckIntervalSeconds : 60);
        _alertTimer.Tick += AlertTimer_Tick;
        if (_settings.Settings.EnableFavoriteServerAlerts || _settings.Settings.EnableManualServerAlerts)
        {
            _alertTimer.Start();
        }
        
        // Alert notification click handler
        _notificationService.AlertClicked += NotificationService_AlertClicked;
        
        // Update service events
        UpdateService.Instance.UpdateAvailable += UpdateService_UpdateAvailable;
        UpdateService.Instance.UpdateReady += UpdateService_UpdateReady;
        UpdateService.Instance.IsApplicationBusy = () => _browserService.IsRefreshing;
    }
    
    private void AutoRefreshTimer_Tick(object? sender, EventArgs e)
    {
        if (_settings.Settings.AutoRefresh)
        {
            _ = RefreshServersAsync();
        }
    }
    
    private void UpdateAutoRefreshTimer()
    {
        _autoRefreshTimer.Stop();
        if (_settings.Settings.AutoRefresh)
        {
            var intervalMinutes = _settings.Settings.AutoRefreshIntervalMinutes;
            if (intervalMinutes < 1) intervalMinutes = 5;
            _autoRefreshTimer.Interval = TimeSpan.FromMinutes(intervalMinutes);
            _autoRefreshTimer.Start();
            _logger.Info($"Auto-refresh enabled: every {intervalMinutes} minutes");
        }
        else
        {
            _logger.Info("Auto-refresh disabled");
        }
    }

    #endregion

    #region Settings

    private void LoadSettings()
    {
        var settings = _settings.Settings;
        
        // Window position and size
        if (settings.WindowX >= 0 && settings.WindowY >= 0)
        {
            Position = new PixelPoint(settings.WindowX, settings.WindowY);
        }
        if (settings.WindowWidth > 0 && settings.WindowHeight > 0)
        {
            Width = settings.WindowWidth;
            Height = settings.WindowHeight;
        }
        if (settings.WindowMaximized)
        {
            WindowState = WindowState.Maximized;
        }
        
        // Sorting
        _sortColumnIndex = settings.SortColumnIndex;
        _sortAscending = settings.SortAscending;
        
        // Filters
        if (HideEmptyCheckBox != null) HideEmptyCheckBox.IsChecked = settings.HideEmpty;
        if (HideBotOnlyCheckBox != null) HideBotOnlyCheckBox.IsChecked = settings.TreatBotOnlyAsEmpty;
        if (HideFullCheckBox != null) HideFullCheckBox.IsChecked = settings.HideFull;
        if (HidePasswordedCheckBox != null) HidePasswordedCheckBox.IsChecked = settings.HidePassworded;
        if (GameModeComboBox != null && settings.GameModeFilterIndex >= 0 && settings.GameModeFilterIndex < GameModes.Count)
        {
            GameModeComboBox.SelectedIndex = settings.GameModeFilterIndex;
        }
        if (SearchBox != null) SearchBox.Text = settings.SearchText ?? "";
        
        // View menu check states
        UpdateMenuCheckMark(ShowLogPanelMenuItem, settings.ShowLogPanel);
        UpdateMenuCheckMark(VerboseLoggingMenuItem, settings.VerboseLogging);
        UpdateMenuCheckMark(RefreshOnLaunchMenuItem, settings.RefreshOnLaunch);
        UpdateMenuCheckMark(AutoRefreshMenuItem, settings.AutoRefresh);
        UpdateMenuCheckMark(AutoRefreshFavoritesOnlyMenuItem, settings.AutoRefreshFavoritesOnly);
        
        // Apply verbose logging to logger
        _logger.VerboseMode = settings.VerboseLogging;
        
        // Splitter positions - restore row/column sizes from settings FIRST
        var mainGrid = MainContentGrid;
        if (mainGrid != null && mainGrid.RowDefinitions.Count >= 3 && settings.MainSplitterDistance > 0)
        {
            mainGrid.RowDefinitions[0].Height = new GridLength(settings.MainSplitterDistance, GridUnitType.Pixel);
            mainGrid.RowDefinitions[2].Height = new GridLength(settings.DetailsSplitterDistance > 0 ? settings.DetailsSplitterDistance : 250, GridUnitType.Pixel);
        }
        
        // Log panel height - only restore if log panel is visible
        if (settings.ShowLogPanel && settings.LogSplitterDistance > 0 && mainGrid != null && mainGrid.RowDefinitions.Count >= 5)
        {
            mainGrid.RowDefinitions[4].Height = new GridLength(settings.LogSplitterDistance, GridUnitType.Pixel);
        }
        
        // Log panel visibility - do this AFTER splitter restore so it can override row 0 sizing
        SetLogPanelVisible(settings.ShowLogPanel);
        
        // Auto-refresh timer
        UpdateAutoRefreshTimer();
        
        // WAD settings
        var searchPaths = settings.WadSearchPaths ?? [];
        _wadManager.SetSearchPaths(searchPaths);
        _wadManager.DownloadPath = !string.IsNullOrEmpty(settings.WadDownloadPath) 
            ? settings.WadDownloadPath 
            : System.IO.Path.Combine(AppContext.BaseDirectory, "WADs");
        
        // Set executable folders for WAD discovery
        var exePaths = new System.Collections.Generic.List<string>();
        if (!string.IsNullOrEmpty(settings.ZandronumPath))
            exePaths.Add(settings.ZandronumPath);
        _wadManager.SetExecutableFolders(exePaths);
        _wadManager.RefreshCache();
    }
    
    private void UpdateMenuCheckMark(MenuItem? menuItem, bool isChecked)
    {
        if (menuItem == null) return;
        menuItem.Icon = isChecked ? new TextBlock { Text = "\u2713" } : null;
    }
    
    private void SetLogPanelVisible(bool visible)
    {
        if (LogPanel != null) LogPanel.IsVisible = visible;
        if (LogSplitter != null) LogSplitter.IsVisible = visible;
        
        // Update the row definitions including MinHeight to fully collapse
        var grid = MainContentGrid;
        if (grid != null && grid.RowDefinitions.Count >= 5)
        {
            // Row 3 is the log splitter, Row 4 is the log panel
            grid.RowDefinitions[3].Height = visible ? new GridLength(5) : new GridLength(0);
            grid.RowDefinitions[3].MinHeight = 0;
            grid.RowDefinitions[4].Height = visible ? new GridLength(120, GridUnitType.Pixel) : new GridLength(0);
            grid.RowDefinitions[4].MinHeight = visible ? 50 : 0;
            
            // Ensure row 0 (server list) uses Star sizing so it can expand to fill space
            if (!visible)
            {
                // When log is hidden, make server list expand with star sizing
                grid.RowDefinitions[0].Height = new GridLength(1, GridUnitType.Star);
            }
        }
    }

    private void SaveSettings()
    {
        if (_isInitializing) return;

        var settings = _settings.Settings;
        
        // Window state
        if (WindowState == WindowState.Normal)
        {
            settings.WindowX = Position.X;
            settings.WindowY = Position.Y;
            settings.WindowWidth = (int)Width;
            settings.WindowHeight = (int)Height;
        }
        settings.WindowMaximized = WindowState == WindowState.Maximized;
        
        // Sorting
        settings.SortColumnIndex = _sortColumnIndex;
        settings.SortAscending = _sortAscending;
        
        // Filters
        settings.HideEmpty = HideEmptyCheckBox?.IsChecked ?? false;
        settings.TreatBotOnlyAsEmpty = HideBotOnlyCheckBox?.IsChecked ?? false;
        settings.HideFull = HideFullCheckBox?.IsChecked ?? false;
        settings.HidePassworded = HidePasswordedCheckBox?.IsChecked ?? false;
        settings.GameModeFilterIndex = GameModeComboBox?.SelectedIndex ?? 0;
        settings.SearchText = SearchBox?.Text ?? "";
        
        // WAD settings
        settings.WadSearchPaths = _wadManager.SearchPaths.ToList();
        settings.WadDownloadPath = _wadManager.DownloadPath;
        
        // Splitter positions - save row heights
        var mainGrid = MainContentGrid;
        if (mainGrid != null && mainGrid.RowDefinitions.Count >= 5)
        {
            settings.MainSplitterDistance = (int)mainGrid.RowDefinitions[0].ActualHeight;
            settings.DetailsSplitterDistance = (int)mainGrid.RowDefinitions[2].ActualHeight;
            settings.LogSplitterDistance = (int)mainGrid.RowDefinitions[4].ActualHeight;
        }
        
        _settings.Save();
    }

    #endregion

    #region Server Refresh

    private async Task RefreshServersAsync()
    {
        try
        {
            await _browserService.RefreshAsync();
        }
        catch (Exception ex)
        {
            _logger.Error($"Refresh failed: {ex.Message}");
        }
    }

    private void UpdateServerList()
    {
        // Clear all hover states to prevent stale highlights during list updates
        foreach (var server in Servers)
        {
            server.IsHovered = false;
        }
        
        // Preserve current selection BEFORE any changes
        string? savedAddress = _selectedServer != null 
            ? $"{_selectedServer.Address}:{_selectedServer.Port}" 
            : null;
        
        var allServers = _browserService.Servers.ToList();
        var filtered = ApplyFilters(allServers);
        filtered = SortServers(filtered);
        
        // Build map of new server data by address for efficient lookup
        var newServerMap = new Dictionary<string, (ServerInfo Server, bool IsFavorite, bool IsManual)>();
        for (int i = 0; i < filtered.Count; i++)
        {
            var server = filtered[i];
            var address = $"{server.Address}:{server.Port}";
            var isFavorite = _settings.Settings.FavoriteServers.Contains(address);
            var isManual = _settings.Settings.ManualServers.Any(m => m.FullAddress == address);
            newServerMap[address] = (server, isFavorite, isManual);
        }
        
        // Build expected order of addresses
        var expectedOrder = filtered.Select(s => $"{s.Address}:{s.Port}").ToList();
        
        // Build position map for O(1) lookup
        var expectedPositions = new Dictionary<string, int>();
        for (int i = 0; i < expectedOrder.Count; i++)
        {
            expectedPositions[expectedOrder[i]] = i;
        }
        
        // Update existing items in-place, track which addresses are handled
        var existingAddresses = new HashSet<string>();
        for (int i = Servers.Count - 1; i >= 0; i--)
        {
            var vm = Servers[i];
            if (newServerMap.TryGetValue(vm.AddressDisplay, out var data))
            {
                // Update existing item in-place
                vm.UpdateFrom(data.Server, data.IsFavorite, data.IsManual);
                existingAddresses.Add(vm.AddressDisplay);
            }
            else
            {
                // Remove items no longer in the filtered list
                Servers.RemoveAt(i);
            }
        }
        
        // Add new items that weren't in the existing list
        foreach (var address in expectedOrder)
        {
            if (!existingAddresses.Contains(address))
            {
                var data = newServerMap[address];
                var vm = new ServerViewModel(data.Server, data.IsFavorite, data.IsManual);
                if (address == savedAddress)
                {
                    vm.IsSelected = true;
                }
                Servers.Add(vm);
            }
        }
        
        // Efficient reordering: sort in-place based on expected positions (O(n log n))
        var sortedList = Servers.OrderBy(vm => 
            expectedPositions.TryGetValue(vm.AddressDisplay, out var pos) ? pos : int.MaxValue
        ).ToList();
        
        // Only update if order changed
        bool orderChanged = false;
        for (int i = 0; i < sortedList.Count && !orderChanged; i++)
        {
            if (i >= Servers.Count || Servers[i].AddressDisplay != sortedList[i].AddressDisplay)
                orderChanged = true;
        }
        
        if (orderChanged)
        {
            Servers.Clear();
            foreach (var vm in sortedList)
            {
                Servers.Add(vm);
            }
        }
        
        // Restore selection state
        if (savedAddress != null)
        {
            foreach (var vm in Servers)
            {
                vm.IsSelected = vm.AddressDisplay == savedAddress;
            }
            _selectedServer = _browserService.Servers.FirstOrDefault(s => 
                $"{s.Address}:{s.Port}" == savedAddress);
        }
        
        UpdateStatusBar();
    }

    private System.Collections.Generic.List<ServerInfo> ApplyFilters(System.Collections.Generic.List<ServerInfo> servers)
    {
        var hideEmpty = HideEmptyCheckBox?.IsChecked ?? false;
        var hideBotOnly = HideBotOnlyCheckBox?.IsChecked ?? false;
        var hideFull = HideFullCheckBox?.IsChecked ?? false;
        var hidePassworded = HidePasswordedCheckBox?.IsChecked ?? false;
        var favoritesOnly = FavoritesOnlyCheckBox?.IsChecked ?? false;
        var searchText = SearchBox?.Text?.Trim() ?? "";
        var gameModeIndex = GameModeComboBox?.SelectedIndex ?? 0;
        
        return servers.Where(s =>
        {
            // Hide offline servers
            if (!s.IsOnline) return false;
            
            // Hide empty
            if (hideEmpty && s.CurrentPlayers == 0) return false;
            
            // Hide bot-only (only servers with bots but no humans - not empty servers)
            if (hideBotOnly && s.CurrentPlayers > 0 && s.CurrentPlayers == s.BotCount) return false;
            
            // Hide full
            if (hideFull && s.CurrentPlayers >= s.MaxPlayers) return false;
            
            // Hide passworded
            if (hidePassworded && s.IsPassworded) return false;
            
            // Favorites only
            if (favoritesOnly)
            {
                var address = $"{s.Address}:{s.Port}";
                if (!_settings.Settings.FavoriteServers.Contains(address))
                    return false;
            }
            
            // Game mode filter
            if (gameModeIndex > 0)
            {
                var selectedMode = GameModes[gameModeIndex];
                if (!s.GameMode.Name.Equals(selectedMode, StringComparison.OrdinalIgnoreCase))
                    return false;
            }
            
            // Search filter
            if (!string.IsNullOrEmpty(searchText))
            {
                var searchLower = searchText.ToLowerInvariant();
                if (!s.Name.Contains(searchText, StringComparison.OrdinalIgnoreCase) &&
                    !s.Map.Contains(searchText, StringComparison.OrdinalIgnoreCase) &&
                    !s.Address.Contains(searchText, StringComparison.OrdinalIgnoreCase) &&
                    !s.IWAD.Contains(searchText, StringComparison.OrdinalIgnoreCase))
                    return false;
            }
            
            // Apply advanced filter (WAD filters, country filters, player counts, etc.)
            if (!_settings.Settings.CurrentFilter.Matches(s))
                return false;
            
            return true;
        }).ToList();
    }

    private System.Collections.Generic.List<ServerInfo> SortServers(System.Collections.Generic.List<ServerInfo> servers)
    {
        // First, separate pinned (favorites/manual) from regular servers
        var pinnedAddresses = new HashSet<string>(
            _settings.Settings.FavoriteServers
                .Concat(_settings.Settings.ManualServers.Select(m => m.FullAddress)));
        
        var pinned = servers.Where(s => pinnedAddresses.Contains($"{s.Address}:{s.Port}")).ToList();
        var regular = servers.Where(s => !pinnedAddresses.Contains($"{s.Address}:{s.Port}")).ToList();
        
        // Sort each group separately
        pinned = SortServerGroup(pinned);
        regular = SortServerGroup(regular);
        
        // Pinned servers always come first
        pinned.AddRange(regular);
        return pinned;
    }
    
    private System.Collections.Generic.List<ServerInfo> SortServerGroup(System.Collections.Generic.List<ServerInfo> servers)
    {
        return _sortColumnIndex switch
        {
            2 => (_sortAscending ? servers.OrderBy(s => s.Name) : servers.OrderByDescending(s => s.Name)).ToList(),
            // Sort by players: prioritize human players, then total players as tiebreaker
            3 => _sortAscending 
                ? servers.OrderBy(s => s.HumanPlayerCount).ThenBy(s => s.CurrentPlayers).ToList()
                : servers.OrderByDescending(s => s.HumanPlayerCount).ThenByDescending(s => s.CurrentPlayers).ToList(),
            4 => (_sortAscending ? servers.OrderBy(s => s.Ping) : servers.OrderByDescending(s => s.Ping)).ToList(),
            5 => (_sortAscending ? servers.OrderBy(s => s.Map) : servers.OrderByDescending(s => s.Map)).ToList(),
            6 => (_sortAscending ? servers.OrderBy(s => s.GameMode.Name) : servers.OrderByDescending(s => s.GameMode.Name)).ToList(),
            7 => (_sortAscending ? servers.OrderBy(s => s.IWAD) : servers.OrderByDescending(s => s.IWAD)).ToList(),
            8 => (_sortAscending ? servers.OrderBy(s => $"{s.Address}:{s.Port}") : servers.OrderByDescending(s => $"{s.Address}:{s.Port}")).ToList(),
            _ => servers
        };
    }

    private void UpdateStatusBar()
    {
        if (ServerCountLabel != null)
            ServerCountLabel.Text = $"Servers: {Servers.Count}";
        
        if (PlayerCountLabel != null)
        {
            var totalPlayers = Servers.Sum(s => s.CurrentPlayers);
            var totalBots = Servers.Sum(s => s.BotCount);
            var totalHumans = totalPlayers - totalBots;
            
            if (totalBots > 0)
            {
                PlayerCountLabel.Text = $"Players: {totalPlayers} ({totalHumans} humans / {totalBots} bots)";
            }
            else
            {
                PlayerCountLabel.Text = $"Players: {totalPlayers}";
            }
        }
    }

    #endregion

    #region Server Details

    private void DisplayServerDetails(ServerInfo server)
    {
        if (ServerDetailsText == null) return;
        
        var sb = new System.Text.StringBuilder();
        sb.AppendLine($"Server: {DoomColorCodes.StripColorCodes(server.Name)}");
        sb.AppendLine($"Address: {server.Address}:{server.Port}");
        sb.AppendLine($"Map: {server.Map}");
        sb.AppendLine($"Mode: {server.GameMode.Name}");
        sb.AppendLine($"Players: {server.CurrentPlayers}/{server.MaxPlayers}");
        sb.AppendLine($"Ping: {server.Ping}ms");
        sb.AppendLine($"IWAD: {server.IWAD}");
        
        if (server.IsPassworded) sb.AppendLine("Password Protected: Yes");
        if (server.IsTestingServer) sb.AppendLine($"Testing Version: {server.GameVersion}");
        
        ServerDetailsText.Text = sb.ToString();
    }

    private void DisplayWadList(ServerInfo server)
    {
        Wads.Clear();
        
        // Add IWAD with status
        if (!string.IsNullOrEmpty(server.IWAD))
        {
            var iwadPath = _wadManager.FindWad(server.IWAD);
            var isAvailable = iwadPath != null;
            var isForbidden = WadManager.IsForbiddenWad(server.IWAD);
            Wads.Add(WadViewModel.Create(server.IWAD, isAvailable, true, isForbidden && !isAvailable));
        }
        
        // Add PWADs
        foreach (var pwad in server.PWADs)
        {
            var wadPath = _wadManager.FindWad(pwad.Name);
            var isAvailable = wadPath != null;
            Wads.Add(WadViewModel.Create(pwad.Name, isAvailable, false));
        }
        
        if (WadsLabel != null)
            WadsLabel.Text = $"WADs ({Wads.Count})";
    }

    private void DisplayPlayerList(ServerInfo server)
    {
        Players.Clear();
        
        // Determine if this game mode uses teams
        bool isTeamGame = server.GameMode.IsTeamGame;
        bool colorizeNames = _settings.Settings.ColorizePlayerNames;
        
        // Update header text based on game mode
        if (TeamHeader != null)
            TeamHeader.Text = isTeamGame ? "Team" : "Status";
        
        // Group by team and spectators
        var spectators = server.Players.Where(p => p.IsSpectator).ToList();
        var players = server.Players.Where(p => !p.IsSpectator).ToList();
        
        // Add team players first, sorted by team
        foreach (var player in players.OrderBy(p => p.Team))
        {
            // Use team color only for team game modes, otherwise white
            var teamColor = isTeamGame ? GetTeamColor(player.Team, server.Teams) : Brushes.White;
            // Use custom team names from server if available
            string teamName = player.Team >= 0 && player.Team < server.Teams.Length
                ? server.Teams[player.Team].Name
                : player.TeamName;
            
            // Get the default color hex for non-colorized fallback
            string defaultColorHex = isTeamGame && teamColor is SolidColorBrush scb
                ? $"#{scb.Color.R:X2}{scb.Color.G:X2}{scb.Color.B:X2}"
                : "#FFFFFF";
            
            var nameSegments = colorizeNames 
                ? DoomColorCodes.ParseColorCodes(player.Name ?? "Unknown", defaultColorHex)
                : [new ColoredTextSegment { Text = DoomColorCodes.StripColorCodes(player.Name ?? "Unknown"), ColorHex = defaultColorHex }];
            
            // Add [BOT] indicator for bots
            if (player.IsBot)
            {
                nameSegments = [.. nameSegments, new ColoredTextSegment { Text = " [BOT]", ColorHex = "#FFA500" }];
            }
            
            Players.Add(new PlayerViewModel
            {
                Name = DoomColorCodes.StripColorCodes(player.Name ?? "Unknown"),
                NameSegments = nameSegments,
                UseColorizedName = colorizeNames,
                Score = player.Score.ToString(),
                Ping = player.Ping.ToString(),
                Team = isTeamGame ? teamName : "Playing",
                TeamColor = isTeamGame ? teamColor : Brushes.LightGreen,
                IsSpectator = false,
                ShowTeamColumn = true
            });
        }
        
        // Add spectators
        foreach (var player in spectators)
        {
            var nameSegments = colorizeNames 
                ? DoomColorCodes.ParseColorCodes(player.Name ?? "Unknown", "#808080")
                : [new ColoredTextSegment { Text = DoomColorCodes.StripColorCodes(player.Name ?? "Unknown"), ColorHex = "#808080" }];
            
            // Add [BOT] indicator for bots
            if (player.IsBot)
            {
                nameSegments = [.. nameSegments, new ColoredTextSegment { Text = " [BOT]", ColorHex = "#FFA500" }];
            }
            
            Players.Add(new PlayerViewModel
            {
                Name = DoomColorCodes.StripColorCodes(player.Name ?? "Unknown"),
                NameSegments = nameSegments,
                UseColorizedName = colorizeNames,
                Score = "-",
                Ping = player.Ping.ToString(),
                Team = "Spectating",
                TeamColor = Brushes.Gray,
                IsSpectator = true,
                ShowTeamColumn = true
            });
        }
        
        if (PlayersLabel != null)
            PlayersLabel.Text = $"Players ({server.Players.Count})";
    }
    
    private static IBrush GetTeamColor(int team, TeamInfo[] teams)
    {
        // Use custom team color from server if available
        if (team >= 0 && team < teams.Length)
        {
            var teamInfo = teams[team];
            if (!string.IsNullOrEmpty(teamInfo.ColorHex) && teamInfo.ColorHex.StartsWith('#'))
            {
                try
                {
                    var color = Color.Parse(teamInfo.ColorHex);
                    return new SolidColorBrush(color);
                }
                catch
                {
                    // Fall through to default colors
                }
            }
        }
        
        // Default team colors
        return team switch
        {
            0 => new SolidColorBrush(Color.FromRgb(100, 149, 237)), // Blue
            1 => new SolidColorBrush(Color.FromRgb(220, 20, 60)),   // Red
            2 => new SolidColorBrush(Color.FromRgb(50, 205, 50)),   // Green
            3 => new SolidColorBrush(Color.FromRgb(255, 215, 0)),   // Gold
            _ => Brushes.White
        };
    }

    #endregion

    #region Event Handlers - Menu

    private void RefreshMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        _ = RefreshServersAsync();
    }

    private void StopMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        _browserService.CancelRefresh();
    }

    private void ExitMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        Close();
    }
    
    private async void FetchWadsMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        var dialog = new FetchWadsDialog();
        await dialog.ShowDialog(this);
        
        if (!dialog.Confirmed || dialog.WadNames.Count == 0)
            return;
        
        var settings = _settings.Settings;
        var downloadPath = settings.WadDownloadPath;
        
        if (string.IsNullOrEmpty(downloadPath))
        {
            downloadPath = Path.Combine(
                Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                "ZScape", "Downloads");
            Directory.CreateDirectory(downloadPath);
        }
        
        // Create WadInfo objects for each WAD name
        var wadsToDownload = dialog.WadNames.Select(name => new WadInfo(name)).ToList();
        
        // Create downloader with configured sources
        var downloader = new WadDownloader(
            dialog.UseWadHostingSites ? settings.DownloadSites : []);
        downloader.IdgamesEnabled = dialog.UseIdgames;
        downloader.WebSearchEnabled = dialog.UseWebSearch;
        
        // Show download dialog
        var downloadDialog = new WadDownloadDialog(wadsToDownload, downloadPath, downloader);
        await downloadDialog.ShowDialog(this);
        
        // Refresh WAD cache and update display after downloads complete
        _wadManager.RefreshCache();
        RefreshSelectedServerDetails();
        
        _logger.Info($"Fetch WADs completed");
    }
    
    private void ShowLogPanelMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        _settings.Settings.ShowLogPanel = !_settings.Settings.ShowLogPanel;
        UpdateMenuCheckMark(ShowLogPanelMenuItem, _settings.Settings.ShowLogPanel);
        SetLogPanelVisible(_settings.Settings.ShowLogPanel);
        _settings.Save();
    }
    
    private void VerboseLoggingMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        _settings.Settings.VerboseLogging = !_settings.Settings.VerboseLogging;
        UpdateMenuCheckMark(VerboseLoggingMenuItem, _settings.Settings.VerboseLogging);
        _logger.VerboseMode = _settings.Settings.VerboseLogging;
        _settings.Save();
    }

    private void ShowEmptyMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (HideEmptyCheckBox != null) HideEmptyCheckBox.IsChecked = false;
        UpdateServerList();
    }

    private void ShowFullMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (HideFullCheckBox != null) HideFullCheckBox.IsChecked = false;
        UpdateServerList();
    }

    private void ShowPasswordedMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (HidePasswordedCheckBox != null) HidePasswordedCheckBox.IsChecked = false;
        UpdateServerList();
    }

    private void FavoritesOnlyMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (FavoritesOnlyCheckBox != null)
            FavoritesOnlyCheckBox.IsChecked = !FavoritesOnlyCheckBox.IsChecked;
        UpdateServerList();
    }
    
    private void RefreshOnLaunchMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        _settings.Settings.RefreshOnLaunch = !_settings.Settings.RefreshOnLaunch;
        UpdateMenuCheckMark(RefreshOnLaunchMenuItem, _settings.Settings.RefreshOnLaunch);
        _settings.Save();
    }
    
    private void AutoRefreshMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        _settings.Settings.AutoRefresh = !_settings.Settings.AutoRefresh;
        UpdateMenuCheckMark(AutoRefreshMenuItem, _settings.Settings.AutoRefresh);
        UpdateAutoRefreshTimer();
        _settings.Save();
    }
    
    private void AutoRefreshFavoritesOnlyMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        _settings.Settings.AutoRefreshFavoritesOnly = !_settings.Settings.AutoRefreshFavoritesOnly;
        UpdateMenuCheckMark(AutoRefreshFavoritesOnlyMenuItem, _settings.Settings.AutoRefreshFavoritesOnly);
        _settings.Save();
    }
    
    private async void WadBrowserMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        var dialog = new WadBrowserDialog();
        await dialog.ShowDialog(this);
    }
    
    private async void TestingVersionsMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        var dialog = new TestingVersionManagerDialog();
        await dialog.ShowDialog(this);
    }

    private async void PreferencesMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        var dialog = new UnifiedSettingsDialog();
        await dialog.ShowDialog(this);
        
        // Reload settings after dialog closes
        if (dialog.SettingsChanged)
        {
            LoadSettings();
            _wadManager.RefreshCache();
            UpdateServerList();
        }
    }

    private async void AboutMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        var version = System.Reflection.Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "Unknown";
        var aboutWindow = new Window
        {
            Title = "About ZScape",
            Width = 400,
            Height = 220,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false,
            Content = new StackPanel
            {
                Margin = new Thickness(20),
                Spacing = 10,
                Children =
                {
                    new TextBlock { Text = "ZScape", FontSize = 24, FontWeight = Avalonia.Media.FontWeight.Bold, HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center },
                    new TextBlock { Text = $"Version {version}", HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center },
                    new TextBlock { Text = "Zandronum Server Browser", HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center },
                    new TextBlock { Text = "https://github.com/RaymondTracer/ZScape", HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center, Foreground = Avalonia.Media.Brushes.CornflowerBlue },
                    new Button { Content = "OK", Width = 80, HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center, Margin = new Thickness(0, 15, 0, 0) }
                }
            }
        };
        
        // Wire up OK button
        if (aboutWindow.Content is StackPanel panel && panel.Children.LastOrDefault() is Button okButton)
        {
            okButton.Click += (_, _) => aboutWindow.Close();
        }
        
        await aboutWindow.ShowDialog(this);
    }

    #endregion

    #region Event Handlers - Toolbar

    private void RefreshButton_Click(object? sender, RoutedEventArgs e)
    {
        _ = RefreshServersAsync();
    }

    private void StopButton_Click(object? sender, RoutedEventArgs e)
    {
        _browserService.CancelRefresh();
    }

    private void SearchBox_TextChanged(object? sender, TextChangedEventArgs e)
    {
        UpdateServerList();
    }

    private void FilterCheckBox_Changed(object? sender, RoutedEventArgs e)
    {
        if (!_isInitializing)
        {
            UpdateServerList();
            SaveSettings();
        }
    }

    private void GameModeComboBox_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        if (!_isInitializing)
        {
            UpdateServerList();
            SaveSettings();
        }
    }

    private async void AdvancedFilterButton_Click(object? sender, RoutedEventArgs e)
    {
        try
        {
            var dialog = new ServerFilterDialog(_settings.Settings.CurrentFilter, _settings.Settings.FilterPresets);
            await dialog.ShowDialog(this);
            
            if (dialog.Confirmed)
            {
                _settings.Settings.CurrentFilter = dialog.Filter;
                _settings.Settings.FilterPresets = dialog.Presets;
                _settings.Save();
                UpdateServerList();
            }
        }
        catch (Exception ex)
        {
            _logger.Error($"AdvancedFilterButton_Click failed: {ex}");
        }
    }

    private async void HistoryButton_Click(object? sender, RoutedEventArgs e)
    {
        try
        {
            var dialog = new ConnectionHistoryDialog();
            dialog.SetServerBrowserService(_browserService);
            dialog.ReconnectRequested += async (_, entry) =>
            {
                dialog.Close();
                // Find the server in the browser list or connect directly
                var server = _browserService.Servers.FirstOrDefault(s => 
                    $"{s.Address}:{s.Port}" == entry.FullAddress);
                if (server != null)
                {
                    _selectedServer = server;
                    UpdateServerList();
                _ = LaunchServerAsync(server);
            }
            else
            {
                // Server not in list - try to parse and connect
                _logger.Info($"Reconnecting to: {entry.ServerName} ({entry.FullAddress})");
            }
        };
        await dialog.ShowDialog(this);
        }
        catch (Exception ex)
        {
            _logger.Error($"HistoryButton_Click failed: {ex}");
        }
    }

    #endregion
    
    #region Event Handlers - Context Menu
    
    private void ConnectMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_selectedServer != null)
        {
            _ = LaunchServerAsync(_selectedServer);
        }
    }
    
    private async void DownloadWadsMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_selectedServer == null) return;
        
        var missingWads = _selectedServer.PWADs
            .Where(w => _wadManager.FindWad(w.Name) == null)
            .Select(w => w.Name)
            .ToList();
        
        if (missingWads.Count == 0)
        {
            _logger.Info("All WADs are already available");
            return;
        }
        
        var wadInfos = missingWads.Select(w => new WadInfo(w)).ToList();
        var downloader = new WadDownloader(_settings.Settings.DownloadSites.Count > 0 
            ? _settings.Settings.DownloadSites 
            : null);
        
        var dialog = new WadDownloadDialog(wadInfos, _wadManager.DownloadPath, downloader);
        
        await dialog.ShowDialog(this);
        
        // Refresh WAD cache and update display after downloads complete
        _wadManager.RefreshCache();
        RefreshSelectedServerDetails();
    }
    
    private async void CopyConnectMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_selectedServer == null) return;
        
        var connectCommand = $"+connect {_selectedServer.Address}:{_selectedServer.Port}";
        var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
        if (clipboard != null)
        {
            await clipboard.SetTextAsync(connectCommand);
            _logger.Info($"Copied connect command to clipboard: {connectCommand}");
        }
    }
    
    private async void CopyAddressMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_selectedServer == null) return;
        
        var address = $"{_selectedServer.Address}:{_selectedServer.Port}";
        var clipboard = TopLevel.GetTopLevel(this)?.Clipboard;
        if (clipboard != null)
        {
            await clipboard.SetTextAsync(address);
            _logger.Info($"Copied server address to clipboard: {address}");
        }
    }
    
    private async void RefreshServerMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_selectedServer == null) return;
        
        _logger.Info($"Refreshing server: {_selectedServer.Address}:{_selectedServer.Port}");
        await _browserService.RefreshServerAsync(_selectedServer);
        UpdateServerList();
    }
    
    private void ToggleFavoriteMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        if (_selectedServer == null) return;
        
        var address = $"{_selectedServer.Address}:{_selectedServer.Port}";
        if (_settings.Settings.FavoriteServers.Contains(address))
        {
            _settings.Settings.FavoriteServers.Remove(address);
            _logger.Info($"Removed from favorites: {address}");
        }
        else
        {
            _settings.Settings.FavoriteServers.Add(address);
            _logger.Info($"Added to favorites: {address}");
        }
        _settings.Save();
        UpdateServerList();
    }
    
    private void FavoriteButton_Click(object? sender, RoutedEventArgs e)
    {
        // Get the ServerViewModel from the button's DataContext
        if (sender is Button button && button.DataContext is ServerViewModel vm)
        {
            var address = vm.AddressDisplay;
            if (_settings.Settings.FavoriteServers.Contains(address))
            {
                _settings.Settings.FavoriteServers.Remove(address);
                _logger.Info($"Removed from favorites: {address}");
            }
            else
            {
                _settings.Settings.FavoriteServers.Add(address);
                _logger.Info($"Added to favorites: {address}");
            }
            _settings.Save();
            UpdateServerList();
        }
    }
    
    private async void AddServerMenuItem_Click(object? sender, RoutedEventArgs e)
    {
        var dialog = new AddServerDialog();
        await dialog.ShowDialog(this);
        
        if (dialog.Confirmed)
        {
            var entry = new ManualServerEntry
            {
                Address = dialog.ServerAddress,
                Port = dialog.ServerPort,
                IsFavorite = dialog.AddAsFavorite
            };
            _settings.Settings.ManualServers.Add(entry);
            
            if (dialog.AddAsFavorite)
            {
                _settings.Settings.FavoriteServers.Add($"{dialog.ServerAddress}:{dialog.ServerPort}");
            }
            
            _settings.Save();
            _logger.Info($"Added manual server: {dialog.ServerAddress}:{dialog.ServerPort}");
            
            // Refresh to query the new server
            _ = RefreshServersAsync();
        }
    }

    #endregion

    #region Event Handlers - Server List

    /// <summary>
    /// Handle row click - select the server.
    /// </summary>
    private void ServerRow_PointerPressed(object? sender, PointerPressedEventArgs e)
    {
        if (sender is Border border && border.DataContext is ServerViewModel vm)
        {
            var point = e.GetCurrentPoint(border);
            
            // Skip if middle-button (handled by scroll viewer)
            if (point.Properties.IsMiddleButtonPressed)
            {
                return;
            }
            
            // Deselect all others
            foreach (var server in Servers)
            {
                server.IsSelected = false;
            }
            
            // Select this one
            vm.IsSelected = true;
            
            // Update backing field
            _selectedServer = _browserService.Servers.FirstOrDefault(s => 
                $"{s.Address}:{s.Port}" == vm.AddressDisplay);
            
            if (_selectedServer != null)
            {
                DisplayServerDetails(_selectedServer);
                DisplayWadList(_selectedServer);
                DisplayPlayerList(_selectedServer);
            }
        }
    }
    
    /// <summary>
    /// Handle row double-click - launch the server.
    /// </summary>
    private void ServerRow_DoubleTapped(object? sender, TappedEventArgs e)
    {
        if (sender is Border border && border.DataContext is ServerViewModel vm)
        {
            var server = _browserService.Servers.FirstOrDefault(s => 
                $"{s.Address}:{s.Port}" == vm.AddressDisplay);
            
            if (server != null)
            {
                _ = LaunchServerAsync(server);
            }
        }
    }
    
    /// <summary>
    /// Handle hover enter - highlight the row.
    /// </summary>
    private void ServerRow_PointerEntered(object? sender, PointerEventArgs e)
    {
        if (sender is Border border && border.DataContext is ServerViewModel vm)
        {
            vm.IsHovered = true;
        }
    }
    
    /// <summary>
    /// Handle hover exit - remove highlight.
    /// </summary>
    private void ServerRow_PointerExited(object? sender, PointerEventArgs e)
    {
        if (sender is Border border && border.DataContext is ServerViewModel vm)
        {
            vm.IsHovered = false;
        }
    }
    
    /// <summary>
    /// Handle scroll - clear all hover states to avoid stale highlights.
    /// </summary>
    private void ServerScrollViewer_ScrollChanged(object? sender, ScrollChangedEventArgs e)
    {
        // Clear all hover states when scrolling to avoid visual artifacts
        foreach (var server in Servers)
        {
            if (server.IsHovered)
            {
                server.IsHovered = false;
            }
        }
    }
    
    /// <summary>
    /// Handle middle-click on scroll viewer for server refresh.
    /// </summary>
    private void ServerScrollViewer_PointerPressed(object? sender, PointerPressedEventArgs e)
    {
        var point = e.GetCurrentPoint(_serverScrollViewer);
        if (point.Properties.IsMiddleButtonPressed)
        {
            // Find the row under the pointer
            if (e.Source is Control control)
            {
                var border = control.FindAncestorOfType<Border>();
                if (border?.DataContext is ServerViewModel vm)
                {
                    var server = _browserService.Servers.FirstOrDefault(s => 
                        $"{s.Address}:{s.Port}" == vm.AddressDisplay);
                    
                    if (server != null)
                    {
                        _logger.Info($"Middle-click refresh: {server.Address}:{server.Port}");
                        _ = _browserService.RefreshServerAsync(server);
                        e.Handled = true;
                    }
                }
            }
        }
    }
    
    // Legacy handlers kept for compatibility
    private void ServerGrid_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        // No longer used - selection handled by ServerRow_PointerPressed
    }
    
    private void ServerDataGrid_SelectionChanged(object? sender, SelectionChangedEventArgs e)
    {
        // No longer used - selection handled by ServerRow_PointerPressed
    }
    
    private void ServerDataGrid_DoubleTapped(object? sender, TappedEventArgs e)
    {
        if (_selectedServer != null)
        {
            _ = LaunchServerAsync(_selectedServer);
        }
    }

    private void ServerGrid_DoubleTapped(object? sender, TappedEventArgs e)
    {
        if (_selectedServer != null)
        {
            _ = LaunchServerAsync(_selectedServer);
        }
    }
    
    private void ServerGrid_LoadingRow(object? sender, DataGridRowEventArgs e)
    {
        if (e.Row.DataContext is ServerViewModel vm)
        {
            e.Row.Background = vm.RowBackground;
        }
    }
    
    private void ServerGrid_Sorting(object? sender, DataGridColumnEventArgs e)
    {
        // Map column header to sort index
        var columnName = e.Column.Header?.ToString() ?? "";
        var newSortIndex = columnName switch
        {
            "Server Name" => 2,
            "Players" => 3,
            "Ping" => 4,
            "Map" => 5,
            "Mode" => 6,
            "IWAD" => 7,
            "Address" => 8,
            _ => -1
        };
        
        if (newSortIndex == -1) return;
        
        // Toggle direction if same column, otherwise default to descending for Players, ascending for others
        if (newSortIndex == _sortColumnIndex)
        {
            _sortAscending = !_sortAscending;
        }
        else
        {
            _sortColumnIndex = newSortIndex;
            _sortAscending = newSortIndex != 3; // Players defaults to descending
        }
        
        UpdateServerList();
        SaveSettings();
        
        // Prevent default sorting
        e.Handled = true;
    }
    
    private void SortByColumn(int columnIndex, bool defaultDescending = false)
    {
        if (columnIndex == _sortColumnIndex)
        {
            _sortAscending = !_sortAscending;
        }
        else
        {
            _sortColumnIndex = columnIndex;
            _sortAscending = !defaultDescending;
        }
        UpdateServerList();
        SaveSettings();
    }
    
    private void SortByName_Click(object? sender, RoutedEventArgs e) => SortByColumn(2);
    private void SortByPlayers_Click(object? sender, RoutedEventArgs e) => SortByColumn(3, defaultDescending: true);
    private void SortByPing_Click(object? sender, RoutedEventArgs e) => SortByColumn(4);
    private void SortByMap_Click(object? sender, RoutedEventArgs e) => SortByColumn(5);
    private void SortByMode_Click(object? sender, RoutedEventArgs e) => SortByColumn(6);
    private void SortByIwad_Click(object? sender, RoutedEventArgs e) => SortByColumn(7);
    private void SortByAddress_Click(object? sender, RoutedEventArgs e) => SortByColumn(8);
    
    private void ServerContextMenu_Opening(object? sender, System.ComponentModel.CancelEventArgs e)
    {
        // Update the favorite menu item text based on current server state
        if (_selectedServer != null && ToggleFavoriteMenuItem != null)
        {
            var address = $"{_selectedServer.Address}:{_selectedServer.Port}";
            var isFavorite = _settings.Settings.FavoriteServers.Contains(address);
            ToggleFavoriteMenuItem.Header = isFavorite ? "_Remove from Favorites" : "_Add to Favorites";
        }
    }
    
    private void ServerGrid_PointerPressed(object? sender, PointerPressedEventArgs e)
    {
        // No longer used - handled by ServerScrollViewer_PointerPressed
    }

    private async Task LaunchServerAsync(ServerInfo server)
    {
        var launcher = GameLauncher.Instance;
        
        // Check if executable is configured
        if (!launcher.IsExecutableConfigured(server))
        {
            var exeType = server.IsTestingServer ? "Testing versions folder" : "Stable executable";
            _logger.Warning($"Zandronum {exeType} not configured");
            
            var dialog = new Window
            {
                Title = "Zandronum Path Not Set",
                Width = 400,
                Height = 150,
                WindowStartupLocation = WindowStartupLocation.CenterOwner,
                Content = new StackPanel
                {
                    Margin = new Thickness(20),
                    Spacing = 15,
                    Children =
                    {
                        new TextBlock { Text = $"Zandronum {exeType} is not configured.\n\nWould you like to configure it now in Settings?", TextWrapping = TextWrapping.Wrap },
                        new StackPanel
                        {
                            Orientation = Avalonia.Layout.Orientation.Horizontal,
                            HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right,
                            Spacing = 10,
                            Children =
                            {
                                new Button { Content = "Yes", Width = 80 },
                                new Button { Content = "No", Width = 80 }
                            }
                        }
                    }
                }
            };
            
            var openSettings = false;
            if (dialog.Content is StackPanel sp && sp.Children.LastOrDefault() is StackPanel buttons)
            {
                if (buttons.Children[0] is Button yesBtn) yesBtn.Click += (_, _) => { openSettings = true; dialog.Close(); };
                if (buttons.Children[1] is Button noBtn) noBtn.Click += (_, _) => dialog.Close();
            }
            
            await dialog.ShowDialog(this);
            
            if (openSettings)
            {
                var settingsDialog = new UnifiedSettingsDialog();
                await settingsDialog.ShowDialog(this);
            }
            return;
        }
        
        // For testing servers, check if the specific version is installed
        if (server.IsTestingServer && !launcher.IsTestingVersionInstalled(server))
        {
            var hasArchive = !string.IsNullOrEmpty(server.TestingArchive);
            
            if (hasArchive)
            {
                var confirmDownload = await ShowConfirmDialogAsync(
                    "Testing Version Not Found",
                    $"Testing version '{server.GameVersion}' is not installed.\n\nWould you like to download it now?");
                
                if (confirmDownload)
                {
                    if (!await DownloadTestingVersionAsync(server))
                    {
                        return;
                    }
                }
                else
                {
                    return;
                }
            }
            else
            {
                _logger.Warning($"Testing version '{server.GameVersion}' not installed and no download URL available");
                return;
            }
        }
        
        // Check for missing WADs
        var (allFound, missingWads) = launcher.CheckRequiredWads(server);
        if (!allFound)
        {
            var wadList = string.Join("\n", missingWads.Take(10).Select(w => $"  - {w.Name}"));
            if (missingWads.Count > 10)
                wadList += $"\n  ... and {missingWads.Count - 10} more";
            
            var result = await ShowThreeButtonDialogAsync(
                "Missing WADs",
                $"The following WAD files are missing:\n\n{wadList}\n\nWould you like to download them?",
                "Download", "Skip", "Cancel");
            
            if (result == "Cancel")
                return;
            
            if (result == "Download")
            {
                var wadInfos = missingWads.Select(w => new WadInfo(w.Name, w.Hash)).ToList();
                var downloader = new WadDownloader(_settings.Settings.DownloadSites.Count > 0 
                    ? _settings.Settings.DownloadSites 
                    : null);
                
                var downloadDialog = new WadDownloadDialog(wadInfos, _wadManager.DownloadPath, downloader, isServerJoinContext: true);
                
                await downloadDialog.ShowDialog(this);
                
                _wadManager.RefreshCache();
                
                // Re-check after download
                var (nowFound, stillMissing) = launcher.CheckRequiredWads(server);
                if (!nowFound)
                {
                    _logger.Warning($"Still missing WADs: {string.Join(", ", stillMissing.Take(5).Select(w => w.Name))}");
                    return;
                }
            }
        }
        
        // Verify WAD hashes if server provides them
        if (server.PWADs.Any(p => !string.IsNullOrEmpty(p.Hash)))
        {
            var hashMismatches = await VerifyWadHashesWithDialogAsync(server);
            
            if (hashMismatches.Count > 0)
            {
                var mismatchList = string.Join("\n", hashMismatches.Take(5).Select(m => $"  - {m.WadName}"));
                if (hashMismatches.Count > 5)
                    mismatchList += $"\n  ... and {hashMismatches.Count - 5} more";
                
                var result = await ShowThreeButtonDialogAsync(
                    "WAD Version Mismatch",
                    $"These WADs have different versions than the server expects:\n\n{mismatchList}\n\nProceed anyway?",
                    "Resolve", "Skip", "Cancel");
                
                if (result == "Cancel")
                    return;
                
                if (result == "Resolve")
                {
                    var wadsToDownload = launcher.ResolveHashMismatches(hashMismatches);
                    if (wadsToDownload.Count > 0)
                    {
                        var wadInfoList = wadsToDownload.Select(w => new WadInfo(w)).ToList();
                        var downloader = new WadDownloader(_settings.Settings.DownloadSites.Count > 0 
                            ? _settings.Settings.DownloadSites 
                            : null);
                        
                        var downloadDialog = new WadDownloadDialog(wadInfoList, _wadManager.DownloadPath, downloader, isServerJoinContext: true);
                        
                        await downloadDialog.ShowDialog(this);
                        
                        _wadManager.RefreshCache();
                    }
                }
            }
        }
        
        // Prompt for passwords if needed
        string? connectPassword = null;
        string? joinPassword = null;
        
        if (server.IsPassworded)
        {
            connectPassword = await PromptForPasswordAsync("Connect Password", "This server requires a password to connect:");
            if (connectPassword == null) return;
        }
        
        if (server.RequiresJoinPassword)
        {
            joinPassword = await PromptForPasswordAsync("Join Password", "This server requires a password to join the game:");
            if (joinPassword == null) return;
        }
        
        // Launch the game
        if (launcher.LaunchGame(server, connectPassword, joinPassword))
        {
            _logger.Success($"Launched connection to {server.Name}");
        }
    }
    
    private async Task<List<GameLauncher.WadHashMismatch>> VerifyWadHashesWithDialogAsync(ServerInfo server)
    {
        var settings = SettingsService.Instance.Settings;
        var concurrency = settings.HashVerificationConcurrency;
        bool isConcurrent = concurrency != 1;
        
        // Fixed dialog height - slots will fill the available space
        const int dialogHeight = 500;
        const int headerHeight = 90; // Space for title, progress bar, count label
        const int slotHeight = 20; // Height per file slot
        
        // Calculate how many slots can fit
        int maxSlotsForHeight = (dialogHeight - headerHeight) / slotHeight;
        int displaySlots = isConcurrent ? maxSlotsForHeight : 1;
        
        var progressWindow = new Window
        {
            Title = "Verifying WAD Hashes",
            Width = 500,
            Height = isConcurrent ? dialogHeight : 180,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false
        };
        
        // Main container
        var mainPanel = new StackPanel { Margin = new Thickness(16, 10, 16, 8) };
        
        // Status label - for sequential mode: "Hashing filename.pk3..."
        // For concurrent mode: "Concurrent mode (N files)"
        var statusLabel = new TextBlock 
        { 
            Text = isConcurrent ? $"Concurrent mode ({(concurrency == 0 ? "unlimited" : concurrency.ToString())} files)" : "Initializing...",
            Margin = new Thickness(0, 0, 0, 4),
            FontSize = 14
        };
        mainPanel.Children.Add(statusLabel);
        
        // File label - for sequential only
        var fileLabel = new TextBlock 
        { 
            Text = "",
            Margin = new Thickness(0, 0, 0, 4),
            FontSize = 12,
            Foreground = Brushes.Gray,
            IsVisible = !isConcurrent
        };
        mainPanel.Children.Add(fileLabel);
        
        // Overall progress bar
        var progressBar = new ProgressBar 
        { 
            Height = 20, 
            Minimum = 0, 
            Maximum = 100,
            Margin = new Thickness(0, 0, 0, 4)
        };
        mainPanel.Children.Add(progressBar);
        
        // Count and file size row
        var infoRow = new Grid();
        infoRow.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Star });
        infoRow.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Star });
        
        var countLabel = new TextBlock 
        { 
            Text = "0 / 0",
            FontSize = 12,
            Foreground = Brushes.Gray
        };
        Grid.SetColumn(countLabel, 0);
        infoRow.Children.Add(countLabel);
        
        var fileSizeLabel = new TextBlock 
        { 
            Text = "",
            FontSize = 12,
            Foreground = Brushes.Gray,
            HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right
        };
        Grid.SetColumn(fileSizeLabel, 1);
        infoRow.Children.Add(fileSizeLabel);
        
        mainPanel.Children.Add(infoRow);
        
        // Alternating row colors
        var evenRowBrush = new SolidColorBrush(Color.FromRgb(50, 50, 55));
        var oddRowBrush = Brushes.Transparent;
        
        // Per-file progress panels for concurrent mode
        var fileProgressPanels = new List<(Border Container, ProgressBar Bar, TextBlock Label)>();
        if (isConcurrent)
        {
            var filePanelsContainer = new StackPanel { Margin = new Thickness(0, 4, 0, 0) };
            
            for (int i = 0; i < displaySlots; i++)
            {
                // Use Border for background color, not StackPanel
                var filePanel = new Border 
                { 
                    Padding = new Thickness(4, 2, 4, 2),
                    Background = (i % 2 == 0) ? evenRowBrush : oddRowBrush,
                    IsVisible = false,
                    HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Stretch
                };
                
                var fileInfoRow = new Grid { HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Stretch };
                fileInfoRow.ColumnDefinitions.Add(new ColumnDefinition { Width = new GridLength(1, GridUnitType.Star) });
                fileInfoRow.ColumnDefinitions.Add(new ColumnDefinition { Width = GridLength.Auto });
                
                var fileLabelItem = new TextBlock 
                { 
                    Text = "",
                    FontSize = 14,
                    TextTrimming = Avalonia.Media.TextTrimming.CharacterEllipsis,
                    Margin = new Thickness(0, 0, 8, 0)
                };
                Grid.SetColumn(fileLabelItem, 0);
                fileInfoRow.Children.Add(fileLabelItem);
                
                var miniBar = new ProgressBar
                {
                    Height = 14,
                    Minimum = 0,
                    Maximum = 100,
                    MinWidth = 100,
                    VerticalAlignment = Avalonia.Layout.VerticalAlignment.Center
                };
                Grid.SetColumn(miniBar, 1);
                fileInfoRow.Children.Add(miniBar);
                
                filePanel.Child = fileInfoRow;
                filePanelsContainer.Children.Add(filePanel);
                fileProgressPanels.Add((filePanel, miniBar, fileLabelItem));
            }
            
            mainPanel.Children.Add(filePanelsContainer);
        }
        
        progressWindow.Content = mainPanel;
        
        var cts = new CancellationTokenSource();
        var mismatches = new List<GameLauncher.WadHashMismatch>();
        
        var progress = new Progress<GameLauncher.HashVerificationProgress>(p =>
        {
            if (!isConcurrent)
            {
                statusLabel.Text = p.Status;
                fileLabel.Text = p.CurrentFile;
            }
            
            // Show file-level progress when hashing a single file, overall progress otherwise
            if (!isConcurrent && p.FileSize > 0 && p.BytesProcessed > 0 && p.BytesProcessed < p.FileSize)
            {
                progressBar.Value = Math.Min(100, p.FilePercentComplete);
            }
            else
            {
                progressBar.Value = Math.Min(100, p.OverallPercentComplete);
            }
            
            countLabel.Text = $"{p.CurrentIndex} / {p.TotalFiles}";
            
            // Show per-file progress if concurrent mode
            if (isConcurrent && p.FileProgress != null && p.FileProgress.Count > 0)
            {
                var allInProgress = p.FileProgress
                    .Where(kv => kv.Value.BytesProcessed > 0 && kv.Value.BytesProcessed < kv.Value.TotalBytes)
                    .Select(kv => new
                    {
                        Key = kv.Key,
                        Value = kv.Value,
                        Percent = kv.Value.TotalBytes > 0 ? (int)(kv.Value.BytesProcessed * 100 / kv.Value.TotalBytes) : 0
                    })
                    .OrderByDescending(x => x.Percent)
                    .ToList();
                
                var totalHashing = allInProgress.Count;
                var displayedItems = allInProgress.Take(displaySlots).ToList();
                
                // Update per-file panels
                for (int i = 0; i < fileProgressPanels.Count; i++)
                {
                    var (panel, miniBar, label) = fileProgressPanels[i];
                    if (i < displayedItems.Count)
                    {
                        var item = displayedItems[i];
                        var fileName = Path.GetFileName(item.Key);
                        var processed = item.Value.BytesProcessed / 1024.0 / 1024.0;
                        var total = item.Value.TotalBytes / 1024.0 / 1024.0;
                        miniBar.Value = Math.Min(100, item.Percent);
                        label.Text = $"{fileName}: {item.Percent}% ({processed:F1} / {total:F1} MB)";
                        panel.IsVisible = true;
                    }
                    else
                    {
                        panel.IsVisible = false;
                    }
                }
                
                fileSizeLabel.Text = $"{totalHashing} file(s) hashing";
            }
            else if (p.FileSize > 0)
            {
                fileSizeLabel.Text = $"{p.BytesProcessed / 1024.0 / 1024.0:F2} / {p.FileSize / 1024.0 / 1024.0:F2} MB";
            }
            else
            {
                fileSizeLabel.Text = "";
            }
        });
        
        progressWindow.Opened += async (_, _) =>
        {
            try
            {
                mismatches = await GameLauncher.Instance.VerifyWadHashesAsync(server, progress, cts.Token);
            }
            catch (OperationCanceledException)
            {
                // User cancelled
            }
            finally
            {
                progressWindow.Close();
            }
        };
        
        await progressWindow.ShowDialog(this);
        return mismatches;
    }
    
    private async Task<bool> DownloadTestingVersionAsync(ServerInfo server)
    {
        var launcher = GameLauncher.Instance;
        
        var progressWindow = new Window
        {
            Title = $"Downloading {server.GameVersion}",
            Width = 450,
            Height = 150,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false
        };
        
        var statusLabel = new TextBlock { Text = "Starting download...", Margin = new Thickness(20, 20, 20, 5) };
        var progressBar = new ProgressBar { Margin = new Thickness(20, 5, 20, 5), Height = 20, Minimum = 0, Maximum = 100 };
        var cancelButton = new Button { Content = "Cancel", Width = 100, HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Center, Margin = new Thickness(0, 10, 0, 0) };
        
        progressWindow.Content = new StackPanel
        {
            Children = { statusLabel, progressBar, cancelButton }
        };
        
        var cancelled = false;
        cancelButton.Click += (_, _) => { cancelled = true; progressWindow.Close(); };
        
        var result = false;
        
        void OnProgress(object? sender, (string Message, int Progress) e)
        {
            Dispatcher.UIThread.Post(() =>
            {
                statusLabel.Text = e.Message;
                progressBar.Value = e.Progress;
            });
        }
        
        launcher.DownloadProgress += OnProgress;
        
        progressWindow.Opened += async (_, _) =>
        {
            try
            {
                result = await launcher.DownloadTestingBuildAsync(server);
                if (!cancelled)
                {
                    progressWindow.Close();
                }
            }
            catch
            {
                progressWindow.Close();
            }
        };
        
        await progressWindow.ShowDialog(this);
        
        launcher.DownloadProgress -= OnProgress;
        
        return result && !cancelled;
    }
    
    private async Task<string?> PromptForPasswordAsync(string title, string message)
    {
        var passwordBox = new TextBox { PasswordChar = '\u2022', Width = 300 };
        string? result = null;
        
        var dialog = new Window
        {
            Title = title,
            Width = 380,
            Height = 160,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false,
            Content = new StackPanel
            {
                Margin = new Thickness(20),
                Spacing = 10,
                Children =
                {
                    new TextBlock { Text = message, TextWrapping = TextWrapping.Wrap },
                    passwordBox,
                    new StackPanel
                    {
                        Orientation = Avalonia.Layout.Orientation.Horizontal,
                        HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right,
                        Spacing = 10,
                        Children =
                        {
                            new Button { Content = "OK", Width = 80 },
                            new Button { Content = "Cancel", Width = 80 }
                        }
                    }
                }
            }
        };
        
        if (dialog.Content is StackPanel sp && sp.Children.LastOrDefault() is StackPanel buttons)
        {
            if (buttons.Children[0] is Button okBtn) okBtn.Click += (_, _) => { result = passwordBox.Text; dialog.Close(); };
            if (buttons.Children[1] is Button cancelBtn) cancelBtn.Click += (_, _) => dialog.Close();
        }
        
        await dialog.ShowDialog(this);
        return result;
    }
    
    private async Task<bool> ShowConfirmDialogAsync(string title, string message)
    {
        var result = false;
        var dialog = new Window
        {
            Title = title,
            Width = 400,
            Height = 150,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false,
            Content = new StackPanel
            {
                Margin = new Thickness(20),
                Spacing = 15,
                Children =
                {
                    new TextBlock { Text = message, TextWrapping = TextWrapping.Wrap },
                    new StackPanel
                    {
                        Orientation = Avalonia.Layout.Orientation.Horizontal,
                        HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right,
                        Spacing = 10,
                        Children =
                        {
                            new Button { Content = "Yes", Width = 80 },
                            new Button { Content = "No", Width = 80 }
                        }
                    }
                }
            }
        };
        
        if (dialog.Content is StackPanel sp && sp.Children.LastOrDefault() is StackPanel buttons)
        {
            if (buttons.Children[0] is Button yesBtn) yesBtn.Click += (_, _) => { result = true; dialog.Close(); };
            if (buttons.Children[1] is Button noBtn) noBtn.Click += (_, _) => dialog.Close();
        }
        
        await dialog.ShowDialog(this);
        return result;
    }
    
    private async Task<string> ShowThreeButtonDialogAsync(string title, string message, string button1, string button2, string button3)
    {
        var result = button3; // Default to cancel
        var dialog = new Window
        {
            Title = title,
            Width = 450,
            Height = 200,
            WindowStartupLocation = WindowStartupLocation.CenterOwner,
            CanResize = false,
            Content = new StackPanel
            {
                Margin = new Thickness(20),
                Spacing = 15,
                Children =
                {
                    new ScrollViewer
                    {
                        MaxHeight = 100,
                        Content = new TextBlock { Text = message, TextWrapping = TextWrapping.Wrap }
                    },
                    new StackPanel
                    {
                        Orientation = Avalonia.Layout.Orientation.Horizontal,
                        HorizontalAlignment = Avalonia.Layout.HorizontalAlignment.Right,
                        Spacing = 10,
                        Children =
                        {
                            new Button { Content = button1, Width = 90 },
                            new Button { Content = button2, Width = 90 },
                            new Button { Content = button3, Width = 90 }
                        }
                    }
                }
            }
        };
        
        if (dialog.Content is StackPanel sp && sp.Children.LastOrDefault() is StackPanel buttons)
        {
            if (buttons.Children[0] is Button btn1) btn1.Click += (_, _) => { result = button1; dialog.Close(); };
            if (buttons.Children[1] is Button btn2) btn2.Click += (_, _) => { result = button2; dialog.Close(); };
            if (buttons.Children[2] is Button btn3) btn3.Click += (_, _) => { result = button3; dialog.Close(); };
        }
        
        await dialog.ShowDialog(this);
        return result;
    }

    #endregion

    #region Event Handlers - Browser Service

    private void BrowserService_RefreshStarted(object? sender, EventArgs e)
    {
        Dispatcher.UIThread.Post(() =>
        {
            Servers.Clear();
            if (StopButton != null) StopButton.IsEnabled = true;
            if (StopMenuItem != null) StopMenuItem.IsEnabled = true;
            if (ProgressBar != null)
            {
                ProgressBar.IsVisible = true;
                ProgressBar.Value = 0;
            }
            if (StatusLabel != null) StatusLabel.Text = "Refreshing...";
            UpdateStatusBar();
        });
    }

    private void BrowserService_RefreshProgress(object? sender, int progress)
    {
        Dispatcher.UIThread.Post(() =>
        {
            if (ProgressBar != null) ProgressBar.Value = Math.Min(progress, 100);
            if (StatusLabel != null) StatusLabel.Text = $"Querying servers... {progress}%";
        });
    }

    private void BrowserService_RefreshCompleted(object? sender, RefreshCompletedEventArgs e)
    {
        Dispatcher.UIThread.Post(() =>
        {
            // Flush any remaining log entries
            ProcessPendingLogEntries();
            
            if (StopButton != null) StopButton.IsEnabled = false;
            if (StopMenuItem != null) StopMenuItem.IsEnabled = false;
            if (ProgressBar != null) ProgressBar.IsVisible = false;

            if (e.Success)
            {
                if (StatusLabel != null) StatusLabel.Text = "Ready";
                UpdateServerList();
            }
            else
            {
                if (StatusLabel != null) StatusLabel.Text = $"Error: {e.Error}";
            }
        });
    }

    private void BrowserService_ServerUpdated(object? sender, ServerInfo server)
    {
        // Just mark that an update is needed - the timer will handle it
        _serverListNeedsUpdate = true;
    }
    
    private void ServerListUpdateTimer_Tick(object? sender, EventArgs e)
    {
        if (!_serverListNeedsUpdate) return;
        _serverListNeedsUpdate = false;
        
        UpdateServerList();
        RefreshSelectedServerDetails();
    }
    
    /// <summary>
    /// Refreshes the detail panels (Server Details, WADs, Players) for the currently selected server.
    /// </summary>
    private void RefreshSelectedServerDetails()
    {
        if (_selectedServer == null) return;
        
        // Re-fetch the server from the browser service to get updated info
        var updatedServer = _browserService.Servers.FirstOrDefault(s => 
            s.Address == _selectedServer.Address && s.Port == _selectedServer.Port);
        
        if (updatedServer != null)
        {
            _selectedServer = updatedServer;
            DisplayServerDetails(_selectedServer);
            DisplayWadList(_selectedServer);
            DisplayPlayerList(_selectedServer);
        }
    }

    private void Logger_LogAdded(object? sender, LogEntry entry)
    {
        // Just add to pending list - the _logFlushTimer will process on UI thread
        lock (_logLock)
        {
            _pendingLogEntries.Add(entry);
        }
    }
    
    private void ProcessPendingLogEntries()
    {
        List<LogEntry> entriesToProcess;
        
        lock (_logLock)
        {
            if (_pendingLogEntries.Count == 0)
                return;
            
            entriesToProcess = [.. _pendingLogEntries];
            _pendingLogEntries.Clear();
        }
        
        // Pre-create brushes once for efficiency
        var errorBrush = new SolidColorBrush(Color.FromRgb(255, 99, 71));
        var warningBrush = new SolidColorBrush(Color.FromRgb(255, 215, 0));
        var successBrush = new SolidColorBrush(Color.FromRgb(50, 205, 50));
        var verboseBrush = new SolidColorBrush(Color.FromRgb(169, 169, 169));
        
        foreach (var entry in entriesToProcess)
        {
            var timestamp = entry.Timestamp.ToString("HH:mm:ss");
            var level = entry.Level.ToString().ToUpperInvariant();
            var text = $"[{timestamp}] [{level}] {entry.Message}";
            
            IBrush color = entry.Level switch
            {
                LogLevel.Error => errorBrush,
                LogLevel.Warning => warningBrush,
                LogLevel.Success => successBrush,
                LogLevel.Verbose => verboseBrush,
                _ => Brushes.White
            };
            
            LogEntries.Add(new LogEntryViewModel(text, color));
        }
        
        // Trim excess entries efficiently (remove from start in one batch)
        const int maxLogEntries = 1000;
        if (LogEntries.Count > maxLogEntries)
        {
            int toRemove = LogEntries.Count - maxLogEntries;
            for (int i = 0; i < toRemove; i++)
            {
                LogEntries.RemoveAt(0);
            }
        }
    }

    #endregion

    protected override void OnClosing(WindowClosingEventArgs e)
    {
        SaveSettings();
        _serverListUpdateTimer.Stop();
        _logFlushTimer.Stop();
        _alertTimer.Stop();
        _autoRefreshTimer.Stop();
        _screenshotMonitor.Dispose();
        _notificationService.Dispose();
        _browserService.CancelRefresh();
        _browserService.Dispose();
        base.OnClosing(e);
    }
    
    #region Auto-Detection and Setup
    
    private void AutoDetectPaths()
    {
        var settings = _settings.Settings;
        
        // Auto-detect Zandronum if not configured
        if (string.IsNullOrEmpty(settings.ZandronumPath))
        {
            var detectedPath = AutoDetectZandronumPath();
            if (!string.IsNullOrEmpty(detectedPath))
            {
                settings.ZandronumPath = detectedPath;
                _logger.Info($"Auto-detected Zandronum: {detectedPath}");
            }
        }
        
        // Auto-detect WAD folders if not configured
        if (settings.WadSearchPaths == null || settings.WadSearchPaths.Count == 0)
        {
            var detectedWadPaths = AutoDetectWadSearchPaths();
            if (detectedWadPaths.Count > 0)
            {
                settings.WadSearchPaths = detectedWadPaths;
                _logger.Info($"Auto-detected WAD folders: {string.Join(", ", detectedWadPaths)}");
            }
        }
    }
    
    private static string? AutoDetectZandronumPath()
    {
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        
        var commonPaths = new[]
        {
            // Windows
            @"C:\Zandronum\zandronum.exe",
            @"C:\Games\Zandronum\zandronum.exe",
            @"C:\Program Files\Zandronum\zandronum.exe",
            @"C:\Program Files (x86)\Zandronum\zandronum.exe",
            Path.Combine(localAppData, "Zandronum", "zandronum.exe"),
            Path.Combine(AppContext.BaseDirectory, "zandronum.exe"),
            // Linux
            Path.Combine(homeDir, ".config", "zandronum", "zandronum"),
            "/usr/bin/zandronum",
            "/usr/local/bin/zandronum",
            "/usr/games/zandronum",
            // MacOS
            "/Applications/Zandronum/Zandronum.app/Contents/MacOS/zandronum"
        };
        
        foreach (var path in commonPaths)
        {
            try
            {
                var fullPath = Path.GetFullPath(path);
                if (File.Exists(fullPath))
                {
                    return fullPath;
                }
            }
            catch { }
        }
        
        return null;
    }
    
    private static List<string> AutoDetectWadSearchPaths()
    {
        var foundPaths = new List<string>();
        var documentsFolder = Environment.GetFolderPath(Environment.SpecialFolder.MyDocuments);
        var homeDir = Environment.GetFolderPath(Environment.SpecialFolder.UserProfile);
        var localAppData = Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData);
        
        var commonPaths = new[]
        {
            Path.Combine(documentsFolder, "WADs"),
            Path.Combine(documentsFolder, "Doom", "WADs"),
            Path.Combine(documentsFolder, "Zandronum", "WADs"),
            Path.Combine(documentsFolder, "Doom"),
            Path.Combine(localAppData, "Zandronum"),
            Path.Combine(homeDir, ".config", "zandronum"),
            Path.Combine(AppContext.BaseDirectory, "WADs"),
            @"C:\Zandronum",
            @"C:\Games\Zandronum",
            @"C:\Games\Doom",
        };
        
        foreach (var path in commonPaths)
        {
            try
            {
                var fullPath = Path.GetFullPath(path);
                if (Directory.Exists(fullPath) && !foundPaths.Contains(fullPath))
                {
                    // Check if folder contains any WAD files
                    var hasWads = Directory.EnumerateFiles(fullPath, "*.*", SearchOption.TopDirectoryOnly)
                        .Any(f => WadExtensions.IsSupportedExtension(Path.GetExtension(f)));
                    if (hasWads)
                    {
                        foundPaths.Add(fullPath);
                    }
                }
            }
            catch { }
        }
        
        return foundPaths;
    }
    
    private async Task ShowFirstTimeSetupAsync()
    {
        var dialog = new FirstTimeSetupDialog();
        var result = await dialog.ShowDialog<bool?>(this);
        
        // User cancelled - exit the application
        if (result != true)
        {
            Environment.Exit(0);
        }
    }
    
    private async Task CheckForUpdatesAsync()
    {
        try
        {
            UpdateService.Instance.CleanupOldUpdates();
            
            var savedState = UpdateService.Instance.LoadServerState();
            if (savedState != null)
            {
                _logger.Info($"Detected post-update restart, resuming server query...");
                await _browserService.ResumeFromStateAsync(savedState);
            }
            
            await UpdateService.Instance.PerformAutoUpdateCheckAsync();
        }
        catch (Exception ex)
        {
            _logger.Warning($"Update check failed: {ex.Message}");
        }
    }
    
    #endregion
    
    #region Alert System
    
    private async void AlertTimer_Tick(object? sender, EventArgs e)
    {
        // Only check when window is not focused (background monitoring)
        if (IsActive)
            return;
        
        var settings = _settings.Settings;
        if (!settings.EnableFavoriteServerAlerts && !settings.EnableManualServerAlerts)
            return;
        
        await CheckServersForAlertsAsync();
    }
    
    private async Task CheckServersForAlertsAsync()
    {
        var settings = _settings.Settings;
        var minPlayers = settings.AlertMinPlayers;
        var alertsToShow = new List<(ServerInfo Server, ServerAlertType Type)>();
        
        foreach (var server in _browserService.Servers.Where(s => s.IsOnline && s.IsQueried))
        {
            var address = $"{server.Address}:{server.Port}";
            var hasMinPlayers = server.CurrentPlayers >= minPlayers;
            
            var isFavorite = settings.FavoriteServers.Contains(address);
            var isManual = settings.ManualServers.Any(m => m.FullAddress == address);
            
            if (!isFavorite && !isManual)
                continue;
            
            if (!_serverAlertStates.TryGetValue(address, out var state))
            {
                state = new ServerAlertState();
                _serverAlertStates[address] = state;
            }
            
            var shouldAlert = false;
            var alertType = ServerAlertType.Favorite;
            
            if (isFavorite && settings.EnableFavoriteServerAlerts && hasMinPlayers)
            {
                if (!state.WasOnlineWithPlayers)
                {
                    shouldAlert = true;
                    alertType = ServerAlertType.Favorite;
                }
            }
            
            if (!shouldAlert && isManual && settings.EnableManualServerAlerts && hasMinPlayers)
            {
                if (!state.WasOnlineWithPlayers)
                {
                    shouldAlert = true;
                    alertType = ServerAlertType.Manual;
                }
            }
            
            state.WasOnlineWithPlayers = hasMinPlayers;
            
            if (shouldAlert)
            {
                alertsToShow.Add((server, alertType));
            }
        }
        
        if (alertsToShow.Count > 0)
        {
            if (alertsToShow.Count == 1)
            {
                _notificationService.ShowServerAlert(alertsToShow[0].Server, alertsToShow[0].Type);
            }
            else
            {
                _notificationService.ShowMultipleServersAlert(alertsToShow);
            }
        }
    }
    
    private void NotificationService_AlertClicked(object? sender, ServerAlertEventArgs e)
    {
        Dispatcher.UIThread.Post(() =>
        {
            Activate();
            
            var address = $"{e.Server.Address}:{e.Server.Port}";
            var vm = Servers.FirstOrDefault(s => s.AddressDisplay == address);
            if (vm != null)
            {
                // Deselect all and select this one
                foreach (var server in Servers)
                {
                    server.IsSelected = false;
                }
                vm.IsSelected = true;
                
                // Update _selectedServer and display details
                _selectedServer = _browserService.Servers.FirstOrDefault(s => 
                    $"{s.Address}:{s.Port}" == vm.AddressDisplay);
                
                if (_selectedServer != null)
                {
                    DisplayServerDetails(_selectedServer);
                    DisplayWadList(_selectedServer);
                    DisplayPlayerList(_selectedServer);
                }
            }
        });
    }
    
    #endregion
    
    #region Update System
    
    private void UpdateService_UpdateAvailable(object? sender, UpdateAvailableEventArgs e)
    {
        Dispatcher.UIThread.Post(async () =>
        {
            var settings = _settings.Settings;
            if (settings.UpdateBehavior == UpdateBehavior.CheckOnly)
            {
                var openPage = await ShowConfirmDialogAsync(
                    "Update Available",
                    $"A new version (v{e.NewVersion}) is available!\n\nCurrent version: v{e.CurrentVersion}\n\nWould you like to view the release page?");
                
                if (openPage)
                {
                    UpdateService.Instance.OpenReleasePage();
                }
            }
        });
    }
    
    private void UpdateService_UpdateReady(object? sender, EventArgs e)
    {
        Dispatcher.UIThread.Post(() =>
        {
            ShowUpdateNotification();
        });
    }
    
    private void ShowUpdateNotification()
    {
        if (_updateNotificationPanel != null) return;
        
        var installButton = new Button
        {
            Content = "Install & Restart",
            Margin = new Thickness(10, 0, 0, 0)
        };
        installButton.Click += async (_, _) =>
        {
            var confirm = await ShowConfirmDialogAsync("Install Update", "This will close ZScape and install the update. Continue?");
            if (confirm)
            {
                UpdateService.Instance.InstallUpdate();
            }
        };
        
        var laterButton = new Button
        {
            Content = "Later",
            Margin = new Thickness(10, 0, 0, 0)
        };
        laterButton.Click += (_, _) => HideUpdateNotification();
        
        var releaseNotesButton = new Button
        {
            Content = "Release Notes",
            Margin = new Thickness(10, 0, 0, 0)
        };
        releaseNotesButton.Click += (_, _) => UpdateService.Instance.OpenReleasePage();
        
        _updateNotificationPanel = new Border
        {
            Background = new SolidColorBrush(Color.FromRgb(40, 80, 120)),
            Padding = new Thickness(15, 8),
            Child = new StackPanel
            {
                Orientation = Avalonia.Layout.Orientation.Horizontal,
                Children =
                {
                    new TextBlock
                    {
                        Text = $"Update available: v{UpdateService.Instance.LatestVersion}",
                        VerticalAlignment = Avalonia.Layout.VerticalAlignment.Center,
                        Foreground = Brushes.White
                    },
                    installButton,
                    releaseNotesButton,
                    laterButton
                }
            }
        };
        
        // Insert at top of main content
        if (Content is DockPanel dp && dp.Children.Count > 0)
        {
            DockPanel.SetDock(_updateNotificationPanel, Dock.Top);
            dp.Children.Insert(0, _updateNotificationPanel);
        }
    }
    
    private void HideUpdateNotification()
    {
        if (_updateNotificationPanel != null && Content is DockPanel dp)
        {
            dp.Children.Remove(_updateNotificationPanel);
            _updateNotificationPanel = null;
        }
    }
    
    #endregion
}

/// <summary>
/// Tracks the alert state for a server to avoid duplicate alerts.
/// </summary>
internal class ServerAlertState
{
    public bool WasOnlineWithPlayers { get; set; }
}

/// <summary>
/// View model for server list binding with row coloring.
/// </summary>
public class ServerViewModel : System.ComponentModel.INotifyPropertyChanged
{
    private ServerInfo _server;
    private bool _isFavorite;
    private bool _isManual;
    private bool _isSelected;
    private bool _isHovered;

    public event System.ComponentModel.PropertyChangedEventHandler? PropertyChanged;

    public ServerViewModel(ServerInfo server, bool isFavorite, bool isManual = false)
    {
        _server = server;
        _isFavorite = isFavorite;
        _isManual = isManual;
    }

    /// <summary>
    /// Update this view model in-place with new server data.
    /// </summary>
    public void UpdateFrom(ServerInfo server, bool isFavorite, bool isManual)
    {
        _server = server;
        
        bool favoriteChanged = _isFavorite != isFavorite;
        bool manualChanged = _isManual != isManual;
        
        _isFavorite = isFavorite;
        _isManual = isManual;
        
        // Notify all data-bound properties that may have changed
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(Name)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(PlayersDisplay)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(Ping)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(Map)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(GameModeDisplay)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IWAD)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsPassworded)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(CurrentPlayers)));
        PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(RowBackground)));
        
        if (favoriteChanged)
        {
            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsFavorite)));
            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(FavoriteIcon)));
            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(FavoriteColor)));
            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsPinned)));
        }
        
        if (manualChanged)
        {
            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsManualServer)));
            PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsPinned)));
        }
    }

    public bool IsSelected
    {
        get => _isSelected;
        set
        {
            if (_isSelected != value)
            {
                _isSelected = value;
                PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsSelected)));
            }
        }
    }
    
    public bool IsHovered
    {
        get => _isHovered;
        set
        {
            if (_isHovered != value)
            {
                _isHovered = value;
                PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(IsHovered)));
            }
        }
    }

    public ServerInfo Server => _server;
    public string FavoriteIcon => _isFavorite ? "\u2605" : "\u2606"; // Filled/empty star
    public IBrush FavoriteColor => _isFavorite ? Brushes.Gold : Brushes.Gray;
    public bool IsPassworded => _server.IsPassworded;
    public string Name => DoomColorCodes.StripColorCodes(_server.Name);
    public string PlayersDisplay => _server.BotCount > 0 
        ? $"{_server.HumanPlayerCount}+{_server.BotCount}/{_server.MaxPlayers}"
        : $"{_server.CurrentPlayers}/{_server.MaxPlayers}";
    public int Ping => _server.Ping;
    public string Map => _server.Map;
    public string GameModeDisplay => _server.GameMode.ShortName;
    public string IWAD => _server.IWAD;
    public string AddressDisplay => $"{_server.Address}:{_server.Port}";
    public int CurrentPlayers => _server.CurrentPlayers;
    public int BotCount => _server.BotCount;
    public bool IsFavorite => _isFavorite;
    public bool IsManualServer => _isManual;
    public bool IsPinned => _isFavorite || _isManual;
    
    // Row coloring based on server state
    public IBrush RowBackground
    {
        get
        {
            if (_server.IsFull)
                return new SolidColorBrush(Color.FromRgb(60, 45, 45)); // Dark red tint
            if (_server.IsEmpty)
                return new SolidColorBrush(Color.FromRgb(45, 45, 50)); // Slightly dimmer
            if (_server.IsPassworded)
                return new SolidColorBrush(Color.FromRgb(60, 55, 40)); // Dark yellow tint
            return Brushes.Transparent;
        }
    }
}

/// <summary>
/// View model for player list binding.
/// </summary>
public class PlayerViewModel
{
    public string Name { get; set; } = "";
    public List<ColoredTextSegment> NameSegments { get; set; } = [];
    public string Score { get; set; } = "";
    public string Ping { get; set; } = "";
    public string Team { get; set; } = "";
    public IBrush TeamColor { get; set; } = Brushes.White;
    public bool IsSpectator { get; set; }
    public bool ShowTeamColumn { get; set; } = true;
    public bool UseColorizedName { get; set; } = false;
    
    /// <summary>
    /// Gets the colored name segments as view models for binding.
    /// </summary>
    public List<ColoredSegmentViewModel> ColoredNameParts => 
        NameSegments.Select(ColoredSegmentViewModel.FromSegment).ToList();
}

/// <summary>
/// View model for colored text segment binding.
/// </summary>
public class ColoredSegmentViewModel
{
    public string Text { get; set; } = "";
    public IBrush Color { get; set; } = Brushes.White;
    
    public static ColoredSegmentViewModel FromSegment(ColoredTextSegment segment)
    {
        IBrush brush = Brushes.White;
        try
        {
            if (!string.IsNullOrEmpty(segment.ColorHex) && segment.ColorHex.StartsWith('#'))
            {
                brush = new SolidColorBrush(Avalonia.Media.Color.Parse(segment.ColorHex));
            }
        }
        catch
        {
            // Fall back to white
        }
        return new ColoredSegmentViewModel { Text = segment.Text, Color = brush };
    }
}

/// <summary>
/// View model for WAD list with status coloring.
/// </summary>
public class WadViewModel
{
    public string Name { get; set; } = "";
    public string Status { get; set; } = "";
    public string DisplayText { get; set; } = "";
    public IBrush StatusColor { get; set; } = Brushes.White;
    public bool IsIwad { get; set; }
    
    public static WadViewModel Create(string wadName, bool isAvailable, bool isIwad, bool isForbiddenIwad = false)
    {
        string status;
        IBrush color;
        
        if (isAvailable)
        {
            status = "[OK]";
            color = new SolidColorBrush(Color.FromRgb(50, 205, 50)); // LimeGreen
        }
        else if (isForbiddenIwad)
        {
            status = "[IWAD]";
            color = new SolidColorBrush(Color.FromRgb(255, 255, 0)); // Yellow
        }
        else
        {
            status = "[MISSING]";
            color = new SolidColorBrush(Color.FromRgb(255, 99, 71)); // Tomato
        }
        
        return new WadViewModel
        {
            Name = wadName,
            Status = status,
            DisplayText = $"{status} {wadName}",
            StatusColor = color,
            IsIwad = isIwad
        };
    }
}

/// <summary>
/// View model for log entries with colored text.
/// </summary>
public class LogEntryViewModel
{
    public string Text { get; }
    public IBrush Color { get; }
    
    public LogEntryViewModel(string text, IBrush color)
    {
        Text = text;
        Color = color;
    }
}

/// <summary>
/// Multi-value converter for server row selection/hover background.
/// Combines IsSelected, IsHovered, and RowBackground.
/// </summary>
public class SelectionBackgroundMultiConverter : Avalonia.Data.Converters.IMultiValueConverter
{
    private static readonly IBrush SelectedBrush = new SolidColorBrush(Color.FromRgb(0, 80, 160));
    private static readonly IBrush HoverBrush = new SolidColorBrush(Color.FromRgb(55, 55, 65));
    
    public object? Convert(IList<object?> values, Type targetType, object? parameter, System.Globalization.CultureInfo culture)
    {
        // Expects: IsSelected, IsHovered, RowBackground
        if (values.Count >= 3)
        {
            bool isSelected = values[0] is bool sel && sel;
            bool isHovered = values[1] is bool hov && hov;
            IBrush rowBackground = values[2] as IBrush ?? Brushes.Transparent;
            
            if (isSelected)
            {
                return SelectedBrush;
            }
            if (isHovered)
            {
                return HoverBrush;
            }
            return rowBackground;
        }
        
        // Fallback for 2 values (old format)
        if (values.Count >= 2 && values[0] is bool isSelectedOld && values[1] is IBrush rowBg)
        {
            return isSelectedOld ? SelectedBrush : rowBg;
        }
        
        return Brushes.Transparent;
    }
}
